# Swift + iOS Integration Guide

This guide walks through building the UniFFI-based Swift package, adding it to any iOS-only SwiftUI app, and calling the available APIs. Share this document with other repos that consume MDK so they do not need to inspect the Rust sources.

---

## Overview

- Rust code lives in this repository; the Swift bindings and xcframework live under `swift/MDKPackage`.
- Everything is automated via `just package-swift`, which regenerates bindings, builds static libraries for device + simulator, produces `ios-artifacts/mdk_uniffi.xcframework`, and refreshes the Swift Package structure.
- The exported Swift module is `MDKBindings`. It re-exports a prebuilt binary target (`mdk_uniffi.xcframework`) and the Swift shim generated by UniFFI.
- Runtime storage uses SQLite; pass a writable file path when constructing `Mdk`.
- The binding is synchronous and not thread-safe: keep one `Mdk` instance on a serial queue/actor.

---

## Prerequisites

| Dependency | Notes |
| --- | --- |
| Rust toolchain | The script pins to `1.91.0` via `rustup`. |
| iOS targets | `aarch64-apple-ios` and `aarch64-apple-ios-sim` (installed automatically). |
| Xcode 15+ | Required for Swift 5.9 toolchain and xcframework consumption. |
| `just` | Installed via `brew install just`. |

No additional CocoaPods/SPM dependencies are needed; `libsqlite3` and `libc++` are linked automatically in the package manifest.

---

## Regenerating the Swift Package

Run the automation from the repo root:

```bash
just package-swift
```

The script (see `scripts/package-swift.sh`) performs:

1. Ensures the `1.91.0` toolchain + iOS targets exist.
2. Builds `mdk-uniffi` for device, simulator, and host.
3. Runs `uniffi-bindgen` to regenerate `mdk_uniffi.swift` + headers.
4. Produces `ios-artifacts/mdk_uniffi.xcframework` with the latest static libs and headers.
5. Rebuilds the Swift package layout:
   - `swift/MDKPackage/Binary/mdk_uniffi.xcframework`
   - `swift/MDKPackage/Sources/mdk_uniffiFFI/include/{mdk_uniffiFFI.h,module.modulemap}`
   - `swift/MDKPackage/Sources/MDKBindings/mdk_uniffi.swift`
   - `swift/MDKPackage/Package.swift`

Commit the `swift/MDKPackage` and `ios-artifacts` directories if you want downstream apps to pull them as submodules; otherwise re-run the command before releasing.

---

## Adding the Package to an iOS App

1. In your app’s Xcode workspace choose **File → Add Packages… → Add Local…** and point to `<repo>/swift/MDKPackage`.
2. When prompted, add the `MDKBindings` product to your app target.
3. Xcode will embed the xcframework automatically; no custom build settings are required.
4. In Swift files use `import MDKBindings` to access the APIs.

Because the package contains a binary target, Xcode copies the xcframework into `DerivedData` during each build. Re-run `just package-swift` whenever the Rust code changes, then open Xcode’s package manager UI and tap **Update** to fetch the refreshed artifacts.

---

## Quick Start Example

```swift
import SwiftUI
import MDKBindings

final class MdkModel: ObservableObject {
    private let mdk: Mdk
    @Published var groups: [Group] = []

    init() throws {
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        mdk = try newMdk(dbPath: docs.appendingPathComponent("mdk.sqlite").path)
        refresh()
    }

    func refresh() {
        groups = (try? mdk.getGroups()) ?? []
    }

    func publishMessage(group: Group, senderHex: String, content: String) throws -> String {
        try mdk.createMessage(
            mlsGroupId: group.mlsGroupId,
            senderPublicKey: senderHex,
            content: content,
            kind: 1 // custom Nostr kind
        )
    }
}

struct ContentView: View {
    @StateObject private var model = try! MdkModel()

    var body: some View {
        List(model.groups, id: \.mlsGroupId) { group in
            VStack(alignment: .leading) {
                Text(group.name).font(.headline)
                Text(group.description).font(.subheadline)
            }
        }
        .refreshable { model.refresh() }
    }
}
```

***Threading tip***: keep `MdkModel` on its own actor or dispatch queue. The UniFFI layer enforces a mutex; concurrent calls from multiple threads can deadlock.

---

## Working With Nostr

MDK manages MLS state but expects your app to push/pull Nostr events:

1. **Key package publishing**
   - Call `createKeyPackageForEvent(publicKey:relays:)`.
   - Publish the returned `KeyPackageResult.keyPackage` and associated `tags` as a Nostr event signed by the owner.
2. **Joining groups**
   - When your relay client receives a key-package event, call `parseKeyPackage(eventJson:)`.
   - Welcome events arrive encrypted; feed their wrapper + rumor JSON to `processWelcome(wrapperEventId:rumorEventJson:)`.
   - Use `acceptWelcome` or `declineWelcome` to update local state.
3. **Creating groups**
   - Collect member key-package events JSON strings.
   - Call `createGroup(...)`, publish each returned `welcomeRumorsJson` via Nostr gift wrap, and store the `Group`.
4. **Adding members**
   - Call `addMembers(...)`, publish the `evolutionEventJson`, then deliver any `welcomeRumorsJson` items to the invitees.
5. **Messaging**
   - Call `createMessage(...)` to produce a signed rumor event JSON; publish it, then call `getMessages` to sync.
   - When receiving external messages, persist the raw JSON and feed it through MDK via future APIs (currently `createMessage` is outbound only; inbound processing happens when events are pulled through `processWelcome` and storage watchers—extend as needed).

---

## API Reference

### Construction

| API | Description |
| --- | --- |
| `newMdk(dbPath: String) throws -> Mdk` | Opens/creates the SQLite-backed MDK instance at the supplied path. (See `swift/MDKPackage/Sources/MDKBindings/mdk_uniffi.swift` near line 1977.) |

### Core Methods on `Mdk`

| Method | Signature | Notes |
| --- | --- | --- |
| Key package creation | `createKeyPackageForEvent(publicKey: String, relays: [String]) -> KeyPackageResult` | Generates a key package bound to a Nostr public key + relay list; publish via Nostr `kind:30311` (or your choice). |
| Key package intake | `parseKeyPackage(eventJson: String)` | Parse and store a received key-package event (raw JSON string). |
| Group creation | `createGroup(creatorPublicKey: String, memberKeyPackageEventsJson: [String], name: String, description: String, relays: [String], admins: [String]) -> CreateGroupResult` | Builds a new MLS group, returns the `Group` plus `welcomeRumorsJson` payloads you must publish. |
| Invite members | `addMembers(mlsGroupId: String, keyPackageEventsJson: [String]) -> AddMembersResult` | Adds members to an existing group; publish `evolutionEventJson`, deliver optional `welcomeRumorsJson`. |
| Message creation | `createMessage(mlsGroupId: String, senderPublicKey: String, content: String, kind: UInt16) -> String` | Produces a signed rumor event JSON ready for relay publication. |
| Merge commits | `mergePendingCommit(mlsGroupId: String)` | Apply pending MLS commits after relays acknowledge events. |
| Welcome processing | `processWelcome(wrapperEventId: String, rumorEventJson: String) -> Welcome` | Decrypts a received welcome gift-wrap; follow up with `acceptWelcome`/`declineWelcome`. |
| Welcome decisions | `acceptWelcome(welcomeJson: String)` / `declineWelcome(welcomeJson: String)` | Update local state after handling a welcome (JSON obtained from `Welcome.eventJson`). |
| Queries | `getGroups() -> [Group]`, `getGroup(mlsGroupId: String) -> Group?`, `getMembers(mlsGroupId: String) -> [String]`, `getRelays(mlsGroupId: String) -> [String]` | Inspect current group metadata. |
| Messages | `getMessages(mlsGroupId: String) -> [Message]`, `getMessage(eventId: String) -> Message?` | Fetch stored messages and associated Nostr events. |
| Welcomes | `getPendingWelcomes() -> [Welcome]` | List welcomes awaiting user action. |

All methods throw `MdkUniffiError`:

- `.Storage(String)`: SQLite backend failure.
- `.Mdk(String)`: Core protocol error (invalid state, crypto issue, etc.).
- `.InvalidInput(String)`: Provided strings (hex, JSON, relays) failed validation.

### Data Records

| Type | Key Fields |
| --- | --- |
| `Group` | `mlsGroupId`, `nostrGroupId`, `name`, `description`, optional image data, `adminPubkeys`, `lastMessageId`, `lastMessageAt`, `epoch`, `state`. |
| `Message` | `id`, `mlsGroupId`, `nostrGroupId`, `eventId`, `eventJson`, `processedAt`, `state`. |
| `Welcome` | `id`, `eventJson`, `mlsGroupId`, `nostrGroupId`, `groupName/Description`, optional image info, `groupAdminPubkeys`, `groupRelays`, `welcomer`, `memberCount`, `state`, `wrapperEventId`. |
| `KeyPackageResult` | `keyPackage`, `tags`. |
| `CreateGroupResult` | `group`, `[welcomeRumorsJson]`. |
| `AddMembersResult` | `evolutionEventJson`, optional `[welcomeRumorsJson]`, `mlsGroupId`. |

Field documentation is embedded inline inside `mdk_uniffi.swift`, so Xcode’s Quick Help shows the comments when you option-click a property.

---

## Troubleshooting

| Symptom | Fix |
| --- | --- |
| `MdkUniffiError.Storage("... locked")` | Ensure the db path points to a writable, app-specific directory and avoid concurrent `Mdk` instances. |
| `Invalid input: Invalid public key` | Verify hex strings are 64-char `secp256k1` public keys without prefixes. |
| Swift package missing new APIs | Re-run `just package-swift`, then in Xcode’s Package Dependencies pane click **Update** next to `MDKPackage`. |
| xcframework build failure | Make sure Xcode command line tools are installed (`xcode-select --install`) and you’re on an Apple Silicon machine (targets hard-coded to arm64). |

For deeper issues, run `RUST_LOG=debug just package-swift` and inspect the script output.

---

## Local Smoke Test (macOS)

Need to sanity-check the bindings without opening Xcode? Run:

```bash
just test-swift-bindings
```

This compiles the generated Swift layer and links it directly against the host `libmdk_uniffi.dylib`, then executes `scripts/swift-binding-test.swift`. The script creates a temporary database, generates a sample key package, verifies pending welcomes, and confirms error propagation, giving you quick confidence that the FFI surface still works end-to-end.
